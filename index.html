<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Additive Color Mixing Cube</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: rgba(20, 20, 20, 0.95);
            padding: 20px;
            border-bottom: 2px solid #333;
            backdrop-filter: blur(10px);
        }
        h1 {
            font-size: 28px;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #ff0000, #00ff00, #0000ff, #ff0000);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .subtitle {
            color: #aaa;
            font-size: 14px;
            margin-bottom: 12px;
        }
        #info {
            background: rgba(40, 40, 40, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #444;
        }
        .current-color {
            font-weight: bold;
            font-size: 18px;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px currentColor;
        }
        .mixing-info {
            font-size: 12px;
            color: #bbb;
            text-align: center;
            font-style: italic;
        }
        #container {
            flex: 1;
            position: relative;
        }
        #footer {
            background: rgba(20, 20, 20, 0.95);
            padding: 15px;
            border-top: 2px solid #333;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        .footer-content {
            font-size: 13px;
            color: #888;
        }
        .highlight {
            color: #0ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>✨ Additive Light Color Mixing</h1>
        <p class="subtitle">Watch how light waves combine - unlike pigments, lights ADD to create brighter colors!</p>
        <div id="info">
            <div class="current-color" id="colorInfo">Initializing...</div>
            <div class="mixing-info" id="mixingInfo">Rotating to next combination...</div>
        </div>
    </div>
    <div id="container"></div>
    <div id="footer">
        <div class="footer-content">
            <span class="highlight">Light (Additive):</span> Red + Green = Yellow, All colors = White | 
            <span style="color: #666;">Pigments (Subtractive):</span> Yellow + Blue = Green, All colors = Brown
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var container = document.getElementById('container');
        var colorInfo = document.getElementById('colorInfo');
        var mixingInfo = document.getElementById('mixingInfo');

        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        var camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 0, 6);
        camera.lookAt(0, 0, 0);

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        var vertices = [
            { color: 0xff0000, name: 'Red', x: -1, y: -1, z: -1 },
            { color: 0x00ff00, name: 'Green', x: 1, y: -1, z: -1 },
            { color: 0x0000ff, name: 'Blue', x: 1, y: 1, z: -1 },
            { color: 0x00ffff, name: 'Cyan', desc: 'Green + Blue', x: -1, y: 1, z: -1 },
            { color: 0xffff00, name: 'Yellow', desc: 'Red + Green', x: -1, y: -1, z: 1 },
            { color: 0xff00ff, name: 'Magenta', desc: 'Red + Blue', x: 1, y: -1, z: 1 },
            { color: 0xffffff, name: 'White', desc: 'Red + Green + Blue', x: 1, y: 1, z: 1 },
            { color: 0xff8800, name: 'Orange', x: -1, y: 1, z: 1 },
            { color: 0x666666, name: 'Gray', desc: 'Dimmed White', x: 0, y: 0, z: 0 }
        ];

        var cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        var centerSphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 32, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 })
        );
        scene.add(centerSphere);

        var nodes = [];
        
        for (var i = 0; i < vertices.length; i++) {
            var data = vertices[i];
            
            var nodeGeo = new THREE.SphereGeometry(0.4, 32, 32);
            var nodeMat = new THREE.MeshBasicMaterial({ 
                color: data.color,
                transparent: true,
                opacity: 0.85
            });
            var node = new THREE.Mesh(nodeGeo, nodeMat);
            node.position.set(data.x, data.y, data.z);
            node.userData = { index: i };
            cubeGroup.add(node);
            nodes.push(node);

            var glowGeo = new THREE.SphereGeometry(0.55, 16, 16);
            var glowMat = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.25
            });
            var glow = new THREE.Mesh(glowGeo, glowMat);
            node.add(glow);

            var pointLight = new THREE.PointLight(data.color, 3, 8);
            pointLight.position.set(data.x, data.y, data.z);
            cubeGroup.add(pointLight);
        }

        var edgeMat = new THREE.LineBasicMaterial({ 
            color: 0x333333, 
            transparent: true, 
            opacity: 0.4 
        });
        
        var edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        for (var e = 0; e < edges.length; e++) {
            var conn = edges[e];
            var v1 = vertices[conn[0]];
            var v2 = vertices[conn[1]];
            
            var p1 = new THREE.Vector3(v1.x, v1.y, v1.z);
            var p2 = new THREE.Vector3(v2.x, v2.y, v2.z);
            
            var lineGeo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
            var line = new THREE.Line(lineGeo, edgeMat);
            cubeGroup.add(line);
        }

        var rotationSequence = [
            { targetVertex: 0, rotation: { x: 0.785, y: -0.785, z: 0 } },
            { targetVertex: 1, rotation: { x: 0.785, y: 0.785, z: 0 } },
            { targetVertex: 5, rotation: { x: -0.785, y: 0.785, z: 0 } },
            { targetVertex: 6, rotation: { x: -0.785, y: -0.785, z: 3.14159 } },
            { targetVertex: 2, rotation: { x: -0.785, y: 0.785, z: 3.14159 } },
            { targetVertex: 3, rotation: { x: -0.785, y: -0.785, z: 0 } },
            { targetVertex: 7, rotation: { x: 0.785, y: -0.785, z: 3.14159 } },
            { targetVertex: 4, rotation: { x: 0.785, y: 0.785, z: 3.14159 } },
            { targetVertex: 8, rotation: { x: 0, y: 0, z: 0 } }
        ];

        var time = 0;
        var transitionDuration = 2.5;
        var holdDuration = 1.8;
        var currentRotation = { x: 0.785, y: -0.785, z: 0 };

        function padHex(num) {
            var hex = num.toString(16);
            while (hex.length < 6) {
                hex = '0' + hex;
            }
            return hex;
        }

        function shortestRotation(current, target) {
            var diff = target - current;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            return diff;
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            var cycleTime = (transitionDuration + holdDuration) * rotationSequence.length;
            var normalizedTime = (time % cycleTime) / cycleTime;
            var progress = normalizedTime * rotationSequence.length;
            var currentIdx = Math.floor(progress);
            var nextIdx = (currentIdx + 1) % rotationSequence.length;
            var segmentProgress = progress - currentIdx;

            var holdRatio = holdDuration / (transitionDuration + holdDuration);
            
            var currentStep = rotationSequence[currentIdx];
            var nextStep = rotationSequence[nextIdx];
            var vertexData = vertices[currentStep.targetVertex];
            
            if (segmentProgress > holdRatio) {
                var transitionProgress = (segmentProgress - holdRatio) / (1 - holdRatio);
                var eased = easeInOutCubic(transitionProgress);
                
                var diffX = shortestRotation(currentStep.rotation.x, nextStep.rotation.x);
                var diffY = shortestRotation(currentStep.rotation.y, nextStep.rotation.y);
                var diffZ = shortestRotation(currentStep.rotation.z, nextStep.rotation.z);
                
                cubeGroup.rotation.x = currentStep.rotation.x + diffX * eased;
                cubeGroup.rotation.y = currentStep.rotation.y + diffY * eased;
                cubeGroup.rotation.z = currentStep.rotation.z + diffZ * eased;

                var nextVertexData = vertices[nextStep.targetVertex];
                colorInfo.textContent = vertexData.name + ' → ' + nextVertexData.name;
                colorInfo.style.color = '#' + padHex(vertexData.color);
                mixingInfo.textContent = 'Rotating to next combination...';
            } else {
                cubeGroup.rotation.x = currentStep.rotation.x;
                cubeGroup.rotation.y = currentStep.rotation.y;
                cubeGroup.rotation.z = currentStep.rotation.z;
                
                colorInfo.textContent = vertexData.name;
                colorInfo.style.color = '#' + padHex(vertexData.color);
                if (vertexData.desc) {
                    mixingInfo.textContent = '✨ ' + vertexData.desc;
                } else {
                    mixingInfo.textContent = 'Primary light color';
                }
            }

            var pulseScale = 1 + Math.sin(time * 3) * 0.12;
            centerSphere.scale.set(pulseScale, pulseScale, pulseScale);
            centerSphere.material.color.setHex(vertexData.color);
            centerSphere.material.opacity = 0.6 + Math.sin(time * 3) * 0.2;

            renderer.render(scene, camera);
        }

        animate();

        function handleResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>
