<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Additive Color Mixing Cube</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: #1a1a1a;
            padding: 20px;
            border-bottom: 1px solid #333;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 8px;
        }
        .subtitle {
            color: #999;
            font-size: 14px;
            margin-bottom: 12px;
        }
        #info {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 8px;
        }
        .current-color {
            color: #00ffff;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 8px;
        }
        .hints {
            font-size: 11px;
            color: #666;
            line-height: 1.6;
        }
        .hint {
            margin: 4px 0;
        }
        #container {
            flex: 1;
            position: relative;
        }
        #footer {
            background: #1a1a1a;
            padding: 12px;
            border-top: 1px solid #333;
            text-align: center;
            font-size: 11px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>ðŸŒˆ Additive Color Mixing (Light)</h1>
        <p class="subtitle">Unlike pigments that subtract light, colored lights ADD together to create brighter colors</p>
        <div id="info">
            <div class="current-color" id="colorInfo">Initializing...</div>
            <div class="hints">
                <div class="hint">ðŸ’¡ <span style="color: #ffff00;">Red + Green = Yellow</span> (surprising!)</div>
                <div class="hint">ðŸ’¡ <span style="color: #00ffff;">Green + Blue = Cyan</span></div>
                <div class="hint">ðŸ’¡ <span style="color: #ffffff;">Red + Green + Blue = White</span></div>
            </div>
        </div>
    </div>
    <div id="container"></div>
    <div id="footer">
        In pigments: Yellow + Blue = Green | In light: Red + Green = Yellow âš¡
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        var container = document.getElementById('container');
        var colorInfo = document.getElementById('colorInfo');

        var scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        var camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 8;

        var renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        var colorData = [
            { color: 0xff0000, name: 'Red', x: -1, y: -1, z: -1 },
            { color: 0x00ff00, name: 'Green', x: 1, y: -1, z: -1 },
            { color: 0x0000ff, name: 'Blue', x: 1, y: 1, z: -1 },
            { color: 0x00ffff, name: 'Cyan (Green + Blue)', x: -1, y: 1, z: -1 },
            { color: 0xffff00, name: 'Yellow (Red + Green)', x: -1, y: -1, z: 1 },
            { color: 0xff00ff, name: 'Magenta (Red + Blue)', x: 1, y: -1, z: 1 },
            { color: 0xffffff, name: 'White (All Light)', x: 1, y: 1, z: 1 },
            { color: 0xff8800, name: 'Orange', x: -1, y: 1, z: 1 },
            { color: 0x888888, name: 'Gray (Less Light)', x: 0, y: 0, z: 0 }
        ];

        var cubeGroup = new THREE.Group();
        scene.add(cubeGroup);

        var nodes = [];
        
        for (var i = 0; i < colorData.length; i++) {
            var data = colorData[i];
            
            var geometry = new THREE.SphereGeometry(0.35, 32, 32);
            var material = new THREE.MeshBasicMaterial({ 
                color: data.color,
                transparent: true,
                opacity: 0.9
            });
            var node = new THREE.Mesh(geometry, material);
            node.position.set(data.x, data.y, data.z);
            cubeGroup.add(node);
            nodes.push(node);

            var glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
            var glowMaterial = new THREE.MeshBasicMaterial({
                color: data.color,
                transparent: true,
                opacity: 0.2
            });
            var glow = new THREE.Mesh(glowGeometry, glowMaterial);
            node.add(glow);

            var light = new THREE.PointLight(data.color, 1.5, 6);
            light.position.set(data.x, data.y, data.z);
            cubeGroup.add(light);
        }

        var edgeMaterial = new THREE.LineBasicMaterial({ 
            color: 0x444444, 
            transparent: true, 
            opacity: 0.3 
        });
        
        var edgeConnections = [
            [0, 1], [1, 2], [2, 3], [3, 0],
            [4, 5], [5, 6], [6, 7], [7, 4],
            [0, 4], [1, 5], [2, 6], [3, 7]
        ];

        for (var e = 0; e < edgeConnections.length; e++) {
            var connection = edgeConnections[e];
            var idx1 = connection[0];
            var idx2 = connection[1];
            var pos1 = colorData[idx1];
            var pos2 = colorData[idx2];
            
            var v1 = new THREE.Vector3(pos1.x, pos1.y, pos1.z);
            var v2 = new THREE.Vector3(pos2.x, pos2.y, pos2.z);
            var pointArray = [v1, v2];
            
            var lineGeometry = new THREE.BufferGeometry().setFromPoints(pointArray);
            var line = new THREE.Line(lineGeometry, edgeMaterial);
            cubeGroup.add(line);
        }

        var time = 0;
        var sequence = [0, 1, 5, 6, 2, 3, 7, 4, 8];
        var transitionTime = 3;
        var holdTime = 1.5;

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            var cycleTime = (transitionTime + holdTime) * sequence.length;
            var normalizedTime = (time % cycleTime) / cycleTime;
            var progress = normalizedTime * sequence.length;
            var currentIdx = Math.floor(progress);
            var nextIdx = (currentIdx + 1) % sequence.length;
            var segmentProgress = progress - currentIdx;

            var holdRatio = holdTime / (transitionTime + holdTime);
            
            if (segmentProgress > holdRatio) {
                var transitionProgress = (segmentProgress - holdRatio) / (1 - holdRatio);
                var eased = easeInOutCubic(transitionProgress);
                
                var currVertex = colorData[sequence[currentIdx]];
                var nextVertex = colorData[sequence[nextIdx]];
                
                cubeGroup.position.x = -(currVertex.x + (nextVertex.x - currVertex.x) * eased);
                cubeGroup.position.y = -(currVertex.y + (nextVertex.y - currVertex.y) * eased);
                cubeGroup.position.z = -(currVertex.z + (nextVertex.z - currVertex.z) * eased);

                colorInfo.textContent = colorData[sequence[currentIdx]].name + ' â†’ ' + colorData[sequence[nextIdx]].name;
            } else {
                var vertex = colorData[sequence[currentIdx]];
                cubeGroup.position.set(-vertex.x, -vertex.y, -vertex.z);
                colorInfo.textContent = 'Centered: ' + vertex.name;
            }

            cubeGroup.rotation.y = time * 0.1;
            cubeGroup.rotation.x = Math.sin(time * 0.05) * 0.1;

            for (var n = 0; n < nodes.length; n++) {
                var worldPos = new THREE.Vector3();
                nodes[n].getWorldPosition(worldPos);
                var dist = worldPos.length();
                var scale = dist < 0.5 ? 1 + Math.sin(time * 3) * 0.15 : 1;
                nodes[n].scale.set(scale, scale, scale);
            }

            renderer.render(scene, camera);
        }

        animate();

        function handleResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        window.addEventListener('resize', handleResize);
    </script>
</body>
</html>
